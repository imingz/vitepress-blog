---
tags: [flink]
---

# 窗口 Window

## 概念

Flink 是一种流式计算引擎，主要是来处理无界数据流的，数据源源不断、无穷无尽。想要更加方便高效地处理无界流，一种方式就是将无限数据切割成有限的“数据块”进行处理，这就是所谓的“窗口”（Window）。

所谓的“窗口”，一般就是划定的一段范围，对在这范围内的数据进行处理，就是所谓的窗口计算。

在 Flink 中，窗口其实并不是一个“框”，应该把窗口理解成一个“桶”。在 Flink 中，窗口可以把流切割成有限大小的多个“存储桶”（bucket）；每个数据都会分发到对应的桶中，当到达窗口结束时间时，就对每个桶中收集的数据进行计算处理。

![Alt text](images/image-0.png)

Flink 中窗口并不是静态准备好的，而是动态创建。当有落在这个窗口区间范围的数据达到时，才创建对应的窗口。另外，这里我们认为到达窗口结束时间时，窗口就触发计算并关闭，事实上“触发计算”和“窗口关闭”两个行为也可以分开。

## 分类

Flink 中内置的窗口的的分类：

### 按照驱动类型分

窗口本身是截取有界数据的一种方式，所以窗口一个非常重要的信息其实就是“怎样截取数据”。换句话说，就是以什么标准来开始和结束数据的截取，我们把它叫作窗口的“驱动类型”。

#### 时间窗口 Time Window

时间窗口以时间点来定义窗口的开始（start）和结束（end），所以截取出的就是某一时间段的数据。到达结束时间时，窗口不再收集数据，触发计算输出结果，并将窗口关闭销毁。

#### 计数窗口 CountWindow

计数窗口基于元素的个数来截取数据，到达固定的个数时就触发计算并关闭窗口。每个窗口截取数据的个数，就是窗口的大小。

### 按照窗口分配数据的规则分类

根据分配数据的规则，窗口的具体实现可以分为 4 类：

#### 滚动窗口 Tumbling Windows

滚动窗口有固定的大小，是一种对数据进行“均匀切片”的划分方式。窗口之间没有重叠，也不会有间隔，是“首尾相接”的状态。这是最简单的窗口形式，每个数据都会被分配到一个窗口，而且只会属于一个窗口。

滚动窗口可以基于时间定义，也可以基于数据个数定义；需要的参数只有一个，就 是 窗 口 的 大 小 （ windowSize）。

比如我们可以定义一个长度为 1 小时的滚动时间窗口，那么每个小时就会进行一次统计；
或者定义一个长度为 10 的滚动计数窗口，就会每 10 个数进行一次统计。

滚动窗口应用非常广泛，它可以对每个时间段做聚合统计，很多 BI 分析指标都可以用它来实现。

![Alt text](images/image.png)

#### 滑动窗口 Sliding Windows

滑动窗口的大小也是固定的。但是窗口之间并不是首尾相接的，而是可以“错开”一定的位置。

定义滑动窗口的参数有两个：除去窗口大小（window size）之外，还有一个“滑动步长”（window slide），它其实就代表了窗口计算的频率。窗口在结束时间触发计算输出结果，那么滑动步长就代表了计算频率。

当滑动步长小于窗口大小时，滑动窗口就会出现重叠，这时数据也可能会被同时分配到多个窗口中。而具体的个数，就由窗口大小和滑动步长的比值（size/slide）来决定。

滚动窗口也可以看作是一种特殊的滑动窗口——窗口大小等于滑动步长（size = slide）。

滑动窗口适合计算结果更新频率非常高的场景。

![Alt text](images/image-1.png)

#### 会话窗口 Session Windows

会话窗口，是基于“会话”（session）来来对数据进行分组的。会话窗口只能基于时间来定义。

会话窗口中，最重要的参数就是会话的超时时间，也就是两个会话窗口之间的最小距离。如果相邻两个数据到来的时间间隔（Gap）小于指定的大小（size），那说明还在保持会话，它们就属于同一个窗口；如果 gap 大于 size，那么新来的数据就应该属于新的会话窗口，而前一个窗口就应该关闭了。

会话窗口的长度不固定，起始和结束时间也是不确定的，各个分区之间窗口没有任何关联。会话窗口之间一定是不会重叠的，而且会留有至少为 size 的间隔（sessionGap）。

在一些类似保持会话的场景下，可以使用会话窗口来进行数据的处理统计。

![Alt text](images/image-2.png)

#### 全局窗口 Global Windows

“全局窗口”，这种窗口全局有效，会把相同 key 的所有数据都分配到同一个窗口中。这种窗口没有结束的时候，默认是不会做触发计算的。如果希望它能对数据进行计算处理，还需要自定义“触发器”（Trigger）。

全局窗口没有结束的时间点，所以一般在希望做更加灵活的窗口处理时自定义使用。Flink 中的计数窗口（Count Window），底层就是用全局窗口实现的。

![Alt text](images/image-3.png)

## API 概览

### 按键分区 Keyed 和非按键分区 Non-Keyed

在定义窗口操作之前，首先需要确定，到底是基于按键分区（Keyed）的数据流 KeyedStream 来开窗，还是直接在没有按键分区的 DataStream 上开窗。也就是说，在调用窗口算子之前，是否有 keyBy 操作。

#### 按键分区窗口 Keyed Windows

经过按键分区 keyBy 操作后，数据流会按照 key 被分为多条逻辑流（logical streams），这就是 KeyedStream。基于 KeyedStream 进行窗口操作时，窗口计算会在多个并行子任务上同时执行。相同 key 的数据会被发送到同一个并行子任务，而窗口操作会基于每个 key 进行单独的处理。所以可以认为，每个 key 上都定义了一组窗口，各自独立地进行统计计算。

```java
streamSource.keyBy(...)
        .window(...)
```

#### 非按键分区 Non-Keyed Windows

如果没有进行 keyBy，那么原始的 DataStream 就不会分成多条逻辑流。这时窗口逻辑只能在一个任务（task）上执行，就相当于并行度变成了 1。

::: warning 注意
`windowAll` 本身就是一个非并行的操作，手动调大窗口算子的并行度也是无效的。
:::

```java
streamSource.windowAll(...)
```

### 窗口 API 的调用

窗口操作主要有两个部分：窗口分配器（Window Assigners）和窗口函数（Window Functions）。

其中 `window()` 方法需要传入一个窗口分配器，它指明了窗口的类型；而后面的 `aggregate()` 方法传入一个窗口函数作为参数，它用来定义窗口具体的处理逻辑。窗口分配器有各种形式，而窗口函数的调用方法也不只 `aggregate()` 一种。

```java
stream.keyBy(<key selector>)
        .window(<window assigner>)
        .aggregate(<window function>)
```

## 窗口分配器 Window Assigners

定义窗口分配器（Window Assigners）是构建窗口算子的第一步，它的作用就是定义数据应该被“分配”到哪个窗口。所以可以说，窗口分配器其实就是在指定窗口的类型。

窗口分配器最通用的定义方式，就是调用 `window()` 方法。这个方法需要传入一个 `WindowAssigner` 作为参数，返回 `WindowedStream`。如果是非按键分区窗口，那么直接调用 `windowAll()` 方法，同样传入一个 `WindowAssigner`，返回的是 `AllWindowedStream`。

窗口按照驱动类型可以分成时间窗口和计数窗口，而按照具体的分配规则，又有滚动窗口、滑动窗口、会话窗口、全局窗口四种。除去需要自定义的全局窗口外，其他常用的类型 Flink 中都给出了内置的分配器实现，我们可以方便地调用实现各种需求。
