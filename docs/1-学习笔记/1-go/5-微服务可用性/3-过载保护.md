---
tags: [golang]
---

# 过载保护

## 令牌桶算法

::: details 官方包
[/x/time/rate](https://pkg.go.dev/golang.org/x/time/rate)
:::

是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：

- 假设限制 2r/s，则按照 500 毫秒的固定速率往桶中添加令牌。
- 桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。
- 当一个 n 个字节大小的数据包到达，将从桶中删除 n 个令牌，接着数据包被发送到网络上。
- 如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。

![Alt text](images/3-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/image.png)

## 漏桶算法

::: details 相关库
[/go.uber.org/ratelimit](https://pkg.go.dev/go.uber.org/ratelimit)
:::

作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形
（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：

- 一个固定容量的漏桶，按照常量固定速率流出水滴。
- 如果桶是空的，则不需流出水滴。
- 可以以任意速率流入水滴到漏桶。
- 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。

![Alt text](images/3-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/image-1.png)

## 漏斗桶/令牌桶的缺点

漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是 **被动** 的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。

这些其实都是采用漏斗桶/令牌桶的缺点, 总体来说就是太被动, 不能快速适应流量变化。

因此我们需要一种自适应的限流算法，即: **过载保护**，根据系统当前的负载自动丢弃流量。

## 过载保护

计算系统临近过载时的峰值吞吐作为限流的阈值来进行流量控制，达到系统保护。

- 服务器临近过载时，主动抛弃一定量的负载，目标是自保。
- 在系统稳定的前提下，保持系统的吞吐量。

常见做法：利特尔法则

![利特尔法则](images/3-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/image-2.png)

- CPU、内存作为信号量进行节流。
- 队列管理: 队列长度、LIFO。
- 可控延迟算法: [CoDel](https://blog.csdn.net/dog250/article/details/72849893)。

### 如何计算接近峰值时的系统吞吐？

- CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。
  > ![简单滑动平均](images/3-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/image-3.png)
- Inflight: 当前服务中正在进行的请求的数量。
- Pass&RT: 最近 5s，pass 为每 100ms 采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。
  > ![Alt text](images/3-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/image-4.png)

### 示例

- 我们使用 CPU 的滑动均值（CPU > 800）作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass\* rt) < inflight
- 限流效果生效后，CPU 会在临界值（800）附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU
- 在冷却时间后，重新判断阈值（CPU > 800 ），是否持续进入过载保护。

![Alt text](images/3-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4/image-5.png)

- 蓝线：请求的数量
- 橙线：延迟
- 绿线：成功放行的请求数量
