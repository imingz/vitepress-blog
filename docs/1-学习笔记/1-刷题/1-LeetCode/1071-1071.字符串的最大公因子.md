---
tags: [ğŸ˜¸ ç®€å•, æ•°å­¦, å­—ç¬¦ä¸², å¿…è€ƒ 75]
---

# 1071.å­—ç¬¦ä¸²çš„æœ€å¤§å…¬å› å­ `å¿…è€ƒ 75`

## é¢˜ç›®

å¯¹äºå­—ç¬¦ä¸² `s` å’Œ `t`ï¼Œåªæœ‰åœ¨ `s = t + ... + t`ï¼ˆ`t` è‡ªèº«è¿æ¥ 1 æ¬¡æˆ–å¤šæ¬¡ï¼‰æ—¶ï¼Œæˆ‘ä»¬æ‰è®¤å®š â€œ`t` èƒ½é™¤å°½ `s`â€ã€‚

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² `str1` å’Œ `str2` ã€‚è¿”å› æœ€é•¿å­—ç¬¦ä¸² `x`ï¼Œè¦æ±‚æ»¡è¶³ `x` èƒ½é™¤å°½ `str1` ä¸” `x` èƒ½é™¤å°½ `str2` ã€‚

:::info ç¤ºä¾‹ 1ï¼š
**è¾“å…¥**ï¼šstr1 = "ABCABC", str2 = "ABC"  
**è¾“å‡º**ï¼š"ABC"  
:::

:::info ç¤ºä¾‹ 2ï¼š
**è¾“å…¥**ï¼šstr1 = "ABABAB", str2 = "ABAB"  
**è¾“å‡º**ï¼š"AB"
:::

:::info ç¤ºä¾‹ 3ï¼š
**è¾“å…¥**ï¼šstr1 = "LEET", str2 = "CODE"  
**è¾“å‡º**ï¼š""
:::

**æç¤º**ï¼š

1. $1 <= str1.length, str2.length <= 1000$
2. `str1` å’Œ `str2` ç”±å¤§å†™è‹±æ–‡å­—æ¯ç»„æˆ

## é¢˜è§£

::: details å‚è€ƒ

ä½œè€…ï¼šåŠ›æ‰£å®˜æ–¹é¢˜è§£  
é“¾æ¥ï¼š<https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/143956/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/>  
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰  
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
:::

### æšä¸¾

è®¾è¿™ä¸ªå‰ç¼€ä¸²é•¿åº¦ä¸º $len_x$ï¼Œ`str1` çš„é•¿åº¦ä¸º $len_1$ï¼Œ`str2` çš„é•¿åº¦ä¸º $len_2$ï¼Œåˆ™å‰ç¼€ä¸²çš„é•¿åº¦å¿…ç„¶è¦æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„çº¦æ•°æ‰èƒ½æ»¡è¶³æ¡ä»¶ï¼Œå¦åˆ™æ— æ³•ç»è¿‡è‹¥å¹²æ¬¡æ‹¼æ¥åå¾—åˆ°é•¿åº¦ç›¸ç­‰çš„å­—ç¬¦ä¸²ã€‚

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾ç¬¦åˆé•¿åº¦æ¡ä»¶çš„å‰ç¼€ä¸²ï¼Œå†å»åˆ¤æ–­è¿™ä¸ªå‰ç¼€ä¸²æ‹¼æ¥è‹¥å¹²æ¬¡ä»¥åæ˜¯å¦ç­‰äº `str1` å’Œ `str2` å³å¯ã€‚

ç”±äºé¢˜ç›®è¦æ±‚æœ€é•¿çš„ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ä¸² `res`ï¼Œæ‰€ä»¥å¯ä»¥æŒ‰é•¿åº¦ä»å¤§åˆ°å°æšä¸¾å‰ç¼€ä¸²ï¼Œè¿™æ ·ç¢°åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å‰ç¼€ä¸²è¿”å›å³å¯ã€‚

```go
func gcdOfStrings(str1 string, str2 string) string {
	m, n := len(str1), len(str2)
	for i := min(m, n); i >= 1; i-- {
		if m%i == 0 && n%i == 0 {
			gcd := str1[:i]
			if checkLoop(gcd, str1) && checkLoop(gcd, str2) {
				return gcd
			}
		}
	}
	return ""
}

func checkLoop(whole, section string) bool {
	times := len(section) / len(whole)
	looped := make([]byte, 0, times)
	for i := 1; i <= times; i++ {
		looped = append(looped, []byte(whole)...)
	}
	return string(looped) == section
}

func min(a, b int) int {
	if a < b {
		return a
	} else {
		return b
	}
}
```

### æšä¸¾ä¼˜åŒ–

å…ˆç”¨è¾—è½¬ç›¸é™¤æ³•æ±‚å¾—ä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„æœ€å¤§å…¬çº¦æ•° `gcd(len1,len2)` å–å‡ºè¯¥é•¿åº¦çš„å‰ç¼€ä¸²ï¼Œåˆ¤æ–­ä¸€ä¸‹å®ƒæ˜¯å¦èƒ½ç»è¿‡è‹¥å¹²æ¬¡æ‹¼æ¥å¾—åˆ° `str1` å’Œ `str2` å³å¯ã€‚

::: details è¾—è½¬ç›¸é™¤æ³•æ±‚ gcd

$$
gcd(a, b) = \left\{
    \begin{array}{ll}
        a & b = 0 \\
        gcd(b,a\:{mod}\:b) & b \neq 0
    \end{array}
\right.
$$

```go
func gcd(a, b int) int {
	if b == 0 {
		return a
	}
	return gcd(b, a%b)
}
```

:::

```go
func gcdOfStrings(str1 string, str2 string) string {
	m, n := len(str1), len(str2)
	gcdStr := str1[:gcd(m, n)]
	if checkLoop(gcdStr, str1) && checkLoop(gcdStr, str2) {
		return gcdStr
	}
	return ""
}

func gcd(a, b int) int {
	if b == 0 {
		return a
	}
	return gcd(b, a%b)
}

func checkLoop(whole, section string) bool {
	times := len(section) / len(whole)
	looped := make([]byte, 0, times)
	for i := 1; i <= times; i++ {
		looped = append(looped, []byte(whole)...)
	}
	return string(looped) == section
}
```

### :heart_eyes_cat: æ•°å­¦

**æ€§è´¨**ï¼šå¦‚æœ `str1` å’Œ `str2` æ‹¼æ¥åç­‰äº `str2å’Œ` `str1` æ‹¼æ¥èµ·æ¥çš„å­—ç¬¦ä¸²ï¼ˆæ„æ‹¼æ¥é¡ºåºä¸åŒï¼‰ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­—ç¬¦ä¸² `X`ã€‚

**æ€è·¯**ï¼šå…ˆåˆ¤æ–­ `str1` å’Œ `str2` æ‹¼æ¥åæ˜¯å¦ç­‰äº `str2` å’Œ `str1` æ‹¼æ¥èµ·æ¥çš„å­—ç¬¦ä¸²ï¼Œå¦‚æœç­‰äºç›´æ¥è¾“å‡ºé•¿åº¦ä¸º `gcd(len1,len2)` çš„å‰ç¼€ä¸²å³å¯ï¼Œå¦åˆ™è¿”å›ç©ºä¸²ã€‚

```go
func gcdOfStrings(str1 string, str2 string) string {
	if str1+str2 == str2+str1 {
		return str1[:gcd(len(str1), len(str2))]
	}
	return ""
}

func gcd(a, b int) int {
	if b == 0 {
		return a
	}
	return gcd(b, a%b)
}
```
